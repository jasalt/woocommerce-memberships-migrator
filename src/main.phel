(ns woocommerce-memberships-migrator\main
  (:require phel\pdo :as pdo)
  (:require phel\str :as str)
  (:require woocommerce-memberships-migrator\lib\wp :as wp))

(defmacro read-config
  "Read PHP constant or throw exception if not set.
   Supports default values for optional configs."
  [name & [default]]
  (let [php-const-symbol (symbol (str "php/" name))]
    `(if (php/defined ,name)
       ,php-const-symbol
       (or ,default
           (php/new \RuntimeException (str "PHP constant " ,name " is required but not defined."))))))

(def db-prefix (read-config "SOURCE_MYSQL_DB_PREFIX"))

(def db-connection-string (str "mysql:host=" (read-config "SOURCE_MYSQL_HOST")
                               ";dbname="  (read-config "SOURCE_MYSQL_DB_NAME")
                               ";charset=" (read-config "SOURCE_MYSQL_DB_CHARSET")))

(def remote-db
  (let [conn (pdo/connect db-connection-string
                          (read-config "SOURCE_MYSQL_USER")
                          (read-config "SOURCE_MYSQL_PASSWORD"))]
    (pdo/exec conn (str "SET NAMES " (read-config "SOURCE_MYSQL_DB_CHARSET")
                        " COLLATE "  (read-config "SOURCE_MYSQL_DB_COLLATION")))
    conn))

## TODO substitutions should be user configurable not hard coded
(def de-mojibake-substitutions {"Ã¶" "ö"
                                "Ã¤" "ä"})

(def sql-customer-users
  (str "SELECT
    u.ID,
    u.user_login,
    u.user_pass,
    u.user_nicename,
    u.user_email,
    u.user_registered,
    u.display_name,
    JSON_OBJECTAGG(um.meta_key, um.meta_value) AS user_meta
FROM " db-prefix "users u
JOIN " db-prefix "usermeta um ON u.ID = um.user_id
WHERE u.ID IN (
    SELECT user_id
    FROM " db-prefix "usermeta
    WHERE meta_key = '" db-prefix "capabilities'
    AND meta_value LIKE '%\"customer\";b:1;%'
)
GROUP BY u.ID, u.user_login, u.user_email, u.user_registered, u.display_name
ORDER BY u.ID;"))

(defn get-source-customers []
  (let [customers (wp/pdo-fetch-all remote-db sql-customer-users)]
    customers))

(defn standardize-keys
  "When using custom database prefix, convert keys use standard `wp_` prefix instead of it.
  E.g. `myprefix_capabilities` becomes `wp_capabilities`.
  If using standard prefix, nothing is done."
  [m]
  (if (= "wp_" db-prefix)
    m
    (for [[k v] :pairs m :reduce [m {}]]
      (put m (if (str/starts-with? k db-prefix)
               (str/replace-first k db-prefix "wp_")
               k) v))))

(defn keywordize-keys
  "Converts map keys to keywords.
  Recursively converts nested maps and arrays."
  [m]
  (cond
    (hash-map? m)
    (let [res (transient {})]
      (foreach [k v m]
        (put res (keyword k) (keywordize-keys v)))
      (persistent res))

    (indexed-php-array? m)
    (let [res (transient [])]
      (foreach [v m]
        (push res (keywordize-keys v)))
      (persistent res))

    true m))

(defn decode-sql-json-metas
  "Decodes meta key value pairs returned by JSONOBJECTAGG query which is
  serialized json. Returns Phel hashmap with keyword keys."
  [s]
  (-> s
      (php/json_decode)
      (php/get_object_vars)
      (php->phel)
      (standardize-keys)
      (keywordize-keys)))

(defn deserialize-values [m keys]
  "Deserialize predefined meta key values stored as serialized PHP"
  (for [key :in keys :reduce [acc m]]
    (put acc key (keywordize-keys (php->phel (php/unserialize (get m key)))))))

(defn replace-all
  "Does string replacements according to the `substitutions` map such as {\"Ã¶\" \"ö\" \"Ã¤\" \"ä\"}."
  [s substitutions]
  (for [[from to] :pairs substitutions :reduce [string s]]
    (str/replace string from to)))

(defn de-mojibake-values
  "Brute force fix dual encoding problems of source database strings.
  TODO action user configurable, not hardcoded"
  [m substitutions]
  (for [[k v] :pairs m :reduce [m {}]]
    (put m k (if (string? v)
               (replace-all v substitutions)
               v))))

(defn db-customer-to-map [customer]
  (let [user_meta  # process user_meta returned as JSON separately
        (-> (get customer :user_meta)
            (decode-sql-json-metas)
            ## TODO keys should be user selectable, not hardcoded
            (deserialize-values [:session_tokens :wp_capabilities :_wpcw_subs_expired_check])
            (de-mojibake-values de-mojibake-substitutions))]
    (-> customer
        (de-mojibake-values de-mojibake-substitutions)
        (put :user_meta user_meta))))

## Example db-customer-to-map return value:
## -> {:ID 10 :user_login "foo.bar" :user_pass "\$P\$f00f0f0f0f0f000f0f0f0f00f0f" :user_nicename "foo-bar" :user_email "foo@example.com" :user_registered "2025-03-14 09:58:56" :display_name "Foo Bar" :user_meta {:wp_capabilities {:customer true} :wp_user_level "0" :description "" :last_update "1584178336" :_yoast_wpseo_profile_updated "1584177321" :icl_admin_language "fi" :billing_first_name "Foo" :billing_country "FI" :paying_customer "1" :_aw_user_registered "1" :nickname "foo.bar" :first_name "Foo" :session_tokens {:986da8s7d6f5a87s6d78987as6s67d89d8s76a6sd738417ff {:expiration 1585389210 :ip "123.234.345.456" :ua "Mozilla/5.0 (iPhone; CPU iPhone OS 13_3_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.5 Mobile/15E148 Safari/604.1" :login 15841321234}} :shipping_method "" :billing_last_name "Bar" :last_name "Bar" :billing_email "foo@example.com" :itsec_user_activity_last_seen "15846654321" :admin_color "fresh" :icl_admin_language_migrated_to_wp47 "1" :show_admin_bar_front "true" :billing_city "Helsinki" :syntax_highlighting "true" :locale "fi" :use_ssl "0" :wp_nav_menu_recently_edited "2" :comment_shortcuts "false" :billing_address_1 "Poste Restante" :billing_phone "1234567890" :billing_postcode "00100" :rich_editing "true" :wc_last_active "1584654321" :_aw_persistent_language "fi" :_wpcw_subs_expired_check {:checked true :expires 1584704321} :itsec_user_activity_last_seen_notification_sent "1"}}

## TODO Make user configurable, not hardcoded
(def metas-to-import
  ["nickname" "first_name" "last_name" "description" "locale"
   "last_update" "wc_last_active" "_woocommerce_tracks_anon_id"
   "billing_first_name" "billing_last_name" "billing_company" "billing_address_1" "billing_address_2" "billing_city" "billing_postcode" "billing_country" "billing_state" "billing_phone" "billing_email"
   "shipping_first_name" "shipping_last_name" "shipping_company" "shipping_address_1" "shipping_address_2" "shipping_city" "shipping_postcode" "shipping_country" "shipping_state" "shipping_phone"
   ])

(defn insert-user [user]
  (let [orig-meta (get user :user_meta)
        default-meta {(str wp/wp-prefix "capabilities") (php/serialize (phel->php {"customer" true}))
                      (str wp/wp-prefix "user_level") "0"
                      "legacy_user_id" (get user :ID)}
        user-meta (for [k-str :in metas-to-import :reduce [acc default-meta]
                        :let [orig-value (get orig-meta (keyword k-str))]]
                    (if orig-value (put acc k-str orig-value) acc))
        data {"user_login" (get user :user_login)
              "user_pass" (get user :user_pass)
              "user_nicename" (get user :user_nicename)
              "user_email" (get user :user_email)
              "user_registered" (get user :user_registered)
              "display_name" (get user :display_name)
              "meta_input" user-meta}]
    (php/wp_insert_user (phel->php data))))

(def sql-user-memberships
  (str "SELECT
        p.*,
        JSON_OBJECTAGG(pm.meta_key, pm.meta_value) AS post_meta
        FROM " db-prefix "posts p
        LEFT JOIN " db-prefix "postmeta pm ON p.ID = pm.post_id
        WHERE p.post_status LIKE '%wcm-active%'
        AND p.post_type = 'wc_user_membership'
        GROUP BY p.ID;"))

(defn get-source-user-memberships []
  (wp/pdo-fetch-all remote-db sql-user-memberships))

## TODO make user configurable instead of hard coded
## Defines mapping from old source site membership-plan post_id to new site
(def membership-plan-mapping (php->phel (read-config "MEMBERSHIP_PLAN_MIGRATION_MAPPING")))

## TODO Verify id's with target site db
## (def posts (php/get_posts
##             (to-php-array {"post_type" "wc_membership_plan"})))

(def sql-membership-plans
  (str "SELECT * FROM " db-prefix "posts WHERE post_type = \"wc_membership_plan\""))

(defn get-source-membership-plans []
  (wp/pdo-fetch-all remote-db sql-membership-plans))

(defn db-memberships-to-map [m]
  (for [db-membership :in db-user-memberships :reduce [acc {}]]
           (let [post_meta (-> (get db-membership :post_meta)
                               (decode-sql-json-metas)
                               (de-mojibake-values de-mojibake-substitutions))
                 membership (put db-membership :post_meta post_meta)
                 uid (get membership :post_author)
                 user-memberships (get acc uid)]
             (if user-memberships
               (put acc uid (push user-memberships membership))  # append if user has many
               (put acc uid [membership])))))

#### General process

## 1) Read user memberships {user_id: [membership*]}
## 2) Read users
## 3) Process users:
## - Migrate user
## - Migrate user memberships

(defn process-users [users memberships]
  (dofor [u :in users :let [user (db-customer-to-map u)
                            user-email (get user :user_email)]]

         ## TODO UID for new or existing user
         (if (int? (php/email_exists user-email))
           (println "Existing user: " user-email)
           (do (println "Importing user: " user-email)
               (insert-user user)))

         ## TODO Migrate user memberships
         (dofor [membership :in (get uid memberships) :let [plan-id (get membership :post_parent)]]
                ## Check if user has membership with plan-id and create if not existing
                )

         )
  )

(comment
  (def db-memberships (get-source-user-memberships))
  (count db-memberships)

  ## (let [membership (peek db-user-memberships)]
  ##   (put membership :post_meta (-> (get membership :post_meta)
  ##                                  (decode-sql-json-metas)
  ##                                  (de-mojibake-values de-mojibake-substitutions))))

  (def memberships (db-memberships-to-map db-memberships))

  (keys memberships)
  (count (get memberships 4467))
  (first (get memberships 4467))
  (first
        (for [membership :in db-user-memberships :reduce [acc {}] :let [uid (get membership :post_author)]]
          (put acc uid membership)
          )
        )

  ## -> {:menu_order 0 :post_name "34950" :post_excerpt "" :post_title "" :post_date_gmt "2025-08-04 08:00:36" :post_modified "2025-08-04 11:00:36" :pinged "" :comment_status "open" :post_type "wc_user_membership" :post_author 4925 :post_parent 3130 :post_content_filtered "" :to_ping "" :ID 34950 :guid "https://example.com/?post_type=wc_user_membership&p=34950" :post_modified_gmt "2025-08-04 08:00:36" :ping_status "closed" :post_meta {:_wpml_word_count "0" :_product_id "3132" :_order_id "34949" :_start_date "2025-08-04 08:00:36" :_end_date "2026-08-04 08:00:36"} :post_date "2025-08-04 11:00:36" :comment_count 1 :post_password "um_12354534a41f68a" :post_mime_type "" :post_content "" :post_status "wcm-active"}


  ## Users
  (def source-customers (get-source-customers))

  (count source-customers)

  (import-users (take 5 source-customers))

  (def user (db-customer-to-map (first source-customers)))
  (import-user user)



  ## Misc
  (def membership-plans (get-source-membership-plans))
  (count membership-plans)
  (first membership-plans)
  ## -> {:ID 3130 :post_content "" :post_mime_type "" :post_password "" :post_author 6 :post_type "wc_membership_plan" :post_name "foo-membership" :post_modified "2025-05-20 11:09:15" :post_date "2020-12-19 10:29:31" :post_date_gmt "2020-12-19 08:29:31" :post_title "Foo Membership" :post_excerpt "" :post_content_filtered "" :post_status "publish" :comment_status "closed" :pinged "" :ping_status "closed" :post_modified_gmt "2025-05-20 09:09:15" :to_ping "" :guid "https://example.com/?post_type=wc_membership_plan&#038;p=3130" :post_parent 0 :menu_order 0 :comment_count 0}

  )
