(ns woocommerce-memberships-migrator\main
  (:require phel\pdo :as pdo)
  (:require phel\str :as str)
  (:require phel\trace :refer [dotrace dbg])
  (:require woocommerce-memberships-migrator\lib\wp :as wp))

(def remote-db (var nil))

(defn select-keys
  "TODO PR"
  [m ks]
  (for [[k v] :pairs m :reduce [acc {}]]
    (if (contains-value? ks k)
      (put acc k v) acc)))

(defmacro read-config
  "Read PHP constant or throw exception if not set.
   Supports default values for optional configs."
  [name & [default]]
  (let [php-const-symbol (symbol (str "php/" name))]
    `(if (php/defined ,name)
       ,php-const-symbol
       (or ,default
           (php/new \RuntimeException (str "PHP constant " ,name " is required but not defined."))))))

(defmacro php
  "Calls PHP function with given arguments. Converts arguments to PHP
  data structures using `phel->php` and conversely returned PHP data structure
  back to Phel with `php->phel`.
  TODO could do conversion ONLY when needed."
  [php-function & args]
  (let [php-function-symbol (symbol (str "php/" php-function))
        converted-args (map (fn [arg] `(phel->php ,arg)) args)]
    `(php->phel (,php-function-symbol ,@converted-args))))

(def db-prefix (read-config "SOURCE_MYSQL_DB_PREFIX"))

(def db-connection-string (str "mysql:host=" (read-config "SOURCE_MYSQL_HOST")
                               ";dbname="  (read-config "SOURCE_MYSQL_DB_NAME")
                               ";charset=" (read-config "SOURCE_MYSQL_DB_CHARSET")))

## TODO substitutions should be user configurable not hard coded
(def de-mojibake-substitutions {"Ã¶" "ö" "Ã–" "Ö"
                                "Ã¤" "ä" "Ã„" "Ä"
                                "Ã¥" "å" "Ã©" "é"})

(def sql-customer-users
  (str "SELECT
    u.ID,
    u.user_login,
    u.user_pass,
    u.user_nicename,
    u.user_email,
    u.user_registered,
    u.display_name,
    JSON_OBJECTAGG(um.meta_key, um.meta_value) AS user_meta
FROM " db-prefix "users u
JOIN " db-prefix "usermeta um ON u.ID = um.user_id
WHERE u.ID IN (
    SELECT user_id
    FROM " db-prefix "usermeta
    WHERE meta_key = '" db-prefix "capabilities'
    AND meta_value LIKE '%\"customer\";b:1;%'
)
GROUP BY u.ID, u.user_login, u.user_email, u.user_registered, u.display_name
ORDER BY u.ID;"))

(defn get-source-customers []
  (let [customers (wp/pdo-fetch-all (deref remote-db) sql-customer-users)]
    customers))

(defn standardize-keys
  "When using custom database prefix, convert keys use standard `wp_` prefix instead of it.
  E.g. `myprefix_capabilities` becomes `wp_capabilities`.
  If using standard prefix, nothing is done."
  [m]
  (if (= "wp_" db-prefix)
    m
    (for [[k v] :pairs m :reduce [m {}]]
      (put m (if (str/starts-with? k db-prefix)
               (str/replace-first k db-prefix "wp_")
               k) v))))

(defn keywordize-keys
  "Converts map keys to keywords.
  Recursively converts nested maps and arrays."
  [m]
  (cond
    (hash-map? m)
    (let [res (transient {})]
      (foreach [k v m]
        (put res (keyword k) (keywordize-keys v)))
      (persistent res))

    (indexed-php-array? m)
    (let [res (transient [])]
      (foreach [v m]
        (push res (keywordize-keys v)))
      (persistent res))

    true m))

(defn decode-sql-json-metas
  "Decodes meta key value pairs returned by JSONOBJECTAGG query which is
  serialized json. Returns Phel hashmap with keyword keys."
  [s]
  (-> s
      (php/json_decode)
      (php/get_object_vars)
      (php->phel)
      (standardize-keys)
      (keywordize-keys)))

(defn deserialize-values [m keys]
  "Deserialize predefined meta key values stored as serialized PHP"
  (for [key :in keys :reduce [acc m]]
    (put acc key (keywordize-keys (php->phel (php/unserialize (get m key)))))))

(defn replace-all
  "Does string replacements according to the `substitutions` map such as {\"Ã¶\" \"ö\" \"Ã¤\" \"ä\"}."
  [s substitutions]
  (for [[from to] :pairs substitutions :reduce [string s]]
    (str/replace string from to)))

(defn de-mojibake-values
  "Brute force fix dual encoding problems of source database strings.
  TODO action user configurable, not hardcoded"
  [m substitutions]
  (for [[k v] :pairs m :reduce [m {}]]
    (put m k (if (string? v)
               (replace-all v substitutions)
               v))))

(defn db-customer-to-map [customer]
  (let [user_meta  # process user_meta returned as JSON separately
        (-> (get customer :user_meta)
            (decode-sql-json-metas)
            ## TODO keys should be user selectable, not hardcoded
            (deserialize-values [:session_tokens :wp_capabilities :_wpcw_subs_expired_check])
            (de-mojibake-values de-mojibake-substitutions))]
    (-> customer
        (de-mojibake-values de-mojibake-substitutions)
        (put :user_meta user_meta))))

## Example db-customer-to-map return value:
## -> {:ID 10 :user_login "foo.bar" :user_pass "\$P\$f00f0f0f0f0f000f0f0f0f00f0f" :user_nicename "foo-bar" :user_email "foo@example.com" :user_registered "2025-03-14 09:58:56" :display_name "Foo Bar" :user_meta {:wp_capabilities {:customer true} :wp_user_level "0" :description "" :last_update "1584178336" :_yoast_wpseo_profile_updated "1584177321" :icl_admin_language "fi" :billing_first_name "Foo" :billing_country "FI" :paying_customer "1" :_aw_user_registered "1" :nickname "foo.bar" :first_name "Foo" :session_tokens {:986da8s7d6f5a87s6d78987as6s67d89d8s76a6sd738417ff {:expiration 1585389210 :ip "123.234.345.456" :ua "Mozilla/5.0 (iPhone; CPU iPhone OS 13_3_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.5 Mobile/15E148 Safari/604.1" :login 15841321234}} :shipping_method "" :billing_last_name "Bar" :last_name "Bar" :billing_email "foo@example.com" :itsec_user_activity_last_seen "15846654321" :admin_color "fresh" :icl_admin_language_migrated_to_wp47 "1" :show_admin_bar_front "true" :billing_city "Helsinki" :syntax_highlighting "true" :locale "fi" :use_ssl "0" :wp_nav_menu_recently_edited "2" :comment_shortcuts "false" :billing_address_1 "Poste Restante" :billing_phone "1234567890" :billing_postcode "00100" :rich_editing "true" :wc_last_active "1584654321" :_aw_persistent_language "fi" :_wpcw_subs_expired_check {:checked true :expires 1584704321} :itsec_user_activity_last_seen_notification_sent "1"}}

## TODO Make user configurable, not hardcoded
(def metas-to-import
  ["nickname" "first_name" "last_name" "description" "locale"
   "last_update" "wc_last_active" "_woocommerce_tracks_anon_id"
   "billing_first_name" "billing_last_name" "billing_company" "billing_address_1" "billing_address_2" "billing_city" "billing_postcode" "billing_country" "billing_state" "billing_phone" "billing_email"
   "shipping_first_name" "shipping_last_name" "shipping_company" "shipping_address_1" "shipping_address_2" "shipping_city" "shipping_postcode" "shipping_country" "shipping_state" "shipping_phone"
   ])

(defn insert-user [user]
  (let [orig-meta (get user :user_meta)
        default-meta {"legacy_user_id" (get user :ID)}
        ## migrated-meta (select-keys orig-meta metas-to-import)
        user-meta (for [k-str :in metas-to-import :reduce [acc default-meta]
                        :let [orig-value (get orig-meta (keyword k-str))]]
                    (if orig-value (put acc k-str orig-value) acc))
        data {"user_login" (get user :user_login)
              "user_pass" (get user :user_pass)
              "user_nicename" (get user :user_nicename)
              "user_email" (get user :user_email)
              "user_registered" (get user :user_registered)
              "display_name" (get user :display_name)
              "meta_input" user-meta
              "role" "customer"}]
    (php/wp_insert_user (phel->php data))))

(defn migrate-users
  "Recreate users from remote site."
  [users]
  (let [print-user (fn [email uid legacy-uid]
                     (println (str/pad-right email 32)
                              (str/pad-right (str "ID: " uid) 12)
                              "Legacy ID:" legacy-uid))]

    (dofor [u :in users :let [user         (db-customer-to-map u)
                              email        (get user :user_email)
                              source-uid   (get user :ID)
                              existing-uid (php/email_exists email)]]

           (if (int? existing-uid)
             (do
               (print "Existing user: ")
               (print-user email existing-uid source-uid))

             (let [new-uid (insert-user user)]  ## TODO test creation
               (print "Created user: ")
               (print-user email new-uid source-uid))))))

(def sql-user-memberships
  (str "SELECT
        p.*,
        JSON_OBJECTAGG(pm.meta_key, pm.meta_value) AS post_meta
        FROM " db-prefix "posts p
        LEFT JOIN " db-prefix "postmeta pm ON p.ID = pm.post_id
        WHERE p.post_status LIKE '%wcm-active%'
        AND p.post_type = 'wc_user_membership'
        GROUP BY p.ID;"))

(defn get-source-user-memberships []
  (wp/pdo-fetch-all (deref remote-db) sql-user-memberships))

## TODO make user configurable instead of hard coded
## Defines mapping from old source site membership-plan post_id to new site
(def membership-plan-mapping (php->phel (read-config "MEMBERSHIP_PLAN_MIGRATION_MAPPING")))
## {old-plan-id<int> new-plan-id<int>}

## TODO Verify id's with target site db

(def sql-membership-plans
  (str "SELECT * FROM " db-prefix "posts WHERE post_type = \"wc_membership_plan\""))

(defn get-source-membership-plans []
  (wp/pdo-fetch-all (deref remote-db) sql-membership-plans))

(defn db-memberships-to-map
  "Returns map of memberships by uid"
  [m]
  (for [db-membership :in m :reduce [acc {}]]
           (let [post_meta (-> (get db-membership :post_meta)
                               (decode-sql-json-metas)
                               (de-mojibake-values de-mojibake-substitutions))
                 membership (put db-membership :post_meta post_meta)
                 uid (get membership :post_author)
                 user-memberships (get acc uid)]
             (if user-memberships
               (put acc uid (push user-memberships membership))  # append if user has many
               (put acc uid [membership])))))

(def source-db-memberships  (var nil))
(def source-memberships-by-uid (var nil)) # [{legacy-uid<int> [m*]}]
(def source-customers       (var nil))

(defn user-has-membership-for-plan-id? [uid plan-id]
  (let [existing-memberships  # [plan-id<int>*]
        (->> (php get_posts {:author      uid
                             :post_type   "wc_user_membership"
                             :numberposts -1
                             :post_status "wcm-active"
                             :post_parent plan-id})
             (map |(php/-> $ post_parent))
             (map php/intval))]
    (contains-value? existing-memberships plan-id)))

(defn insert-user-membership
  "Adds membership for user, skipping if it as been previously created.
   Old membership ID is stored in `legacy_membership_id` usermeta."
  [target-uid source-membership]  # [int m]
  (let [{:ID          source-membership-id
         :post_type   post-type
         :post_status post-status
         :post_parent source-membership-plan-id
         :post_meta {:_start_date start-date
                     :_end_date   end-date}} source-membership
        target-membership-plan-id (get membership-plan-mapping source-membership-plan-id)]

    (cond
      ## Check for existing membership
      (user-has-membership-for-plan-id? target-uid target-membership-plan-id)
      (do (println "Skip duplicate"
                   "for User" target-uid "Plan ID" target-membership-plan-id
                   "source-membership-id" source-membership-id))

      ## Validate
      (or (not= post-type "wc_user_membership") (not= post-status "wcm-active"))
      (throw (php/new \InvalidArgumentException
                      (str "Invalid post_type or post_status for membership with id "
                           source-membership-id)))

      ## Add new
      (let [orig-data (select-keys source-membership
                                   [:post_date :post_date_gmt :post_type :post_status])
            new-data {:post_author target-uid
                      :post_parent target-membership-plan-id
                      :meta_input {:_start_date start-date
                                   :_end_date end-date
                                   :legacy_membership_id source-membership-id}}]

        (println "Importing membership" source-membership-id "for user" target-uid)
        (php wp_insert_post (merge orig-data new-data))))))

(defn migrate-memberships [memberships-by-uid]  # [{legacy-uid<int> [m*]}]
  (dofor [[source-uid memberships] :pairs memberships-by-uid
          :let [target-user (first (php get_users {:meta_key "legacy_user_id"
                                                   :meta_value source-uid
                                                   :meta_compare "="}))]]
         (if target-user
           (for [membership :in memberships]
             (insert-user-membership (php/-> target-user ID) membership))
           (println "Target user not found with legacy id" source-uid))))

(defn load-data []
  (let [conn (pdo/connect db-connection-string
                          (read-config "SOURCE_MYSQL_USER")
                          (read-config "SOURCE_MYSQL_PASSWORD"))]
    (pdo/exec conn (str "SET NAMES " (read-config "SOURCE_MYSQL_DB_CHARSET")
                        " COLLATE "  (read-config "SOURCE_MYSQL_DB_COLLATION")))
    (set! remote-db conn))

  (when-not (deref remote-db) (throw (php/new \RuntimeException "Unable to connect to database")))
  (println "Loading data from source database")

  (set! source-customers (get-source-customers))
  (println "Read" (count (deref source-customers)) "customers")

  (set! source-db-memberships (get-source-user-memberships))
  (println "Read" (count (deref source-db-memberships)) "active user memberships")

  (set! source-memberships-by-uid (db-memberships-to-map (deref source-db-memberships)))
  (println (count (keys (deref source-memberships-by-uid))) "users with active memberships"))

(comment
  (migrate-users [(get (deref source-customers) 4)])

  (migrate-memberships (select-keys (deref source-memberships-by-uid) [3097]))  #  3097 4878 4846
  (keys (deref source-memberships-by-uid))


  ## Main logic
  (load-data)
  (migrate-users (deref source-customers))
  (migrate-memberships (deref source-memberships-by-uid))


  ## Memberships
  (first (deref source-db-memberships))
  ## -> {:menu_order 0 :post_name "34950" :post_excerpt "" :post_title "" :post_date_gmt "2025-08-04 08:00:36" :post_modified "2025-08-04 11:00:36" :pinged "" :comment_status "open" :post_type "wc_user_membership" :post_author 4925 :post_parent 3130 :post_content_filtered "" :to_ping "" :ID 34950 :guid "https://example.com/?post_type=wc_user_membership&p=34950" :post_modified_gmt "2025-08-04 08:00:36" :ping_status "closed" :post_meta {:_wpml_word_count "0" :_product_id "3132" :_order_id "34949" :_start_date "2025-08-04 08:00:36" :_end_date "2026-08-04 08:00:36"} :post_date "2025-08-04 11:00:36" :comment_count 1 :post_password "um_12354534a41f68a" :post_mime_type "" :post_content "" :post_status "wcm-active"}
  (get (deref source-memberships-by-uid) 20)


  ## Users
  (def user (db-customer-to-map (first source-customers)))
  (import-user user)

  ## Misc
  (def membership-plans (get-source-membership-plans))
  (count membership-plans)
  (first membership-plans)
  ## -> {:ID 3130 :post_content "" :post_mime_type "" :post_password "" :post_author 6 :post_type "wc_membership_plan" :post_name "foo-membership" :post_modified "2025-05-20 11:09:15" :post_date "2020-12-19 10:29:31" :post_date_gmt "2020-12-19 08:29:31" :post_title "Foo Membership" :post_excerpt "" :post_content_filtered "" :post_status "publish" :comment_status "closed" :pinged "" :ping_status "closed" :post_modified_gmt "2025-05-20 09:09:15" :to_ping "" :guid "https://example.com/?post_type=wc_membership_plan&#038;p=3130" :post_parent 0 :menu_order 0 :comment_count 0}

  )
